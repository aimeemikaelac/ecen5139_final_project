// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2014.1
// Copyright (C) 2014 Xilinx Inc. All rights reserved.
// 
// ==============================================================

// Port list: {  1  }


#ifndef _runQueue_random_priorities_H_
#define _runQueue_random_priorities_H_



#include <systemc>
#include <iostream>
#include <fstream>
#include "AESL_pkg.h"

template<unsigned int READ_PORT_COUNT = 1,
         unsigned int WRITE_PORT_COUNT = 1,
         unsigned int DATA_WIDTH = 8,
         unsigned int ADDRESS_WIDTH = 8,
         unsigned int WORD_COUNT = 256>
struct runQueue_random_priorities_core : public sc_core::sc_module
{
public:
    sc_core::sc_in< sc_dt::sc_lv< WRITE_PORT_COUNT*DATA_WIDTH > > d;
    sc_core::sc_out< sc_dt::sc_lv< READ_PORT_COUNT*DATA_WIDTH > > q;
    sc_core::sc_in < sc_dt::sc_lv< READ_PORT_COUNT*ADDRESS_WIDTH > > ra;
    sc_core::sc_in < sc_dt::sc_lv< READ_PORT_COUNT > > ce;
    sc_core::sc_in < sc_dt::sc_lv< WRITE_PORT_COUNT*ADDRESS_WIDTH > > wa;
    sc_core::sc_in < sc_dt::sc_lv< WRITE_PORT_COUNT > > we;
    sc_core::sc_in <sc_dt::sc_logic>  reset;
    sc_core::sc_in_clk  clk;

    SC_HAS_PROCESS(runQueue_random_priorities_core);
    runQueue_random_priorities_core(sc_core::sc_module_name) {
        mem = new sc_dt::sc_lv< DATA_WIDTH> [WORD_COUNT];

        SC_METHOD(proc_di);
        sensitive << d;

        SC_METHOD(proc_wai);
        sensitive << wa;

        SC_METHOD(proc_mem);
        sensitive << clk.pos();

        SC_METHOD(proc_rai);
        sensitive << ra;

        SC_METHOD(proc_rai_reg);
        sensitive << clk.pos();

        SC_METHOD(proc_qi);
        sensitive << clk.pos();
        for (unsigned i = 0; i < READ_PORT_COUNT; i++) {
            sensitive << rai_reg[i];
        }

        SC_METHOD(proc_q);
        sensitive << qi;

        mem[0] = "101000101";
        mem[1] = "110110101";
        mem[2] = "100100110";
        mem[3] = "011000101";
        mem[4] = "100100111";
        mem[5] = "010110010";
        mem[6] = "101000101";
        mem[7] = "111110100";
        mem[8] = "011001111";
        mem[9] = "110000000";
        mem[10] = "000010000";
        mem[11] = "000010101";
        mem[12] = "001011111";
        mem[13] = "111101011";
        mem[14] = "101101000";
        mem[15] = "000010110";
        mem[16] = "000001010";
        mem[17] = "100000111";
        mem[18] = "100110111";
        mem[19] = "110011010";
        mem[20] = "101111101";
        mem[21] = "101001101";
        mem[22] = "001000001";
        mem[23] = "010111111";
        mem[24] = "010001001";
        mem[25] = "010111000";
        mem[26] = "101100010";
        mem[27] = "001011110";
        mem[28] = "100101110";
        mem[29] = "001101010";
        mem[30] = "100111100";
        mem[31] = "110100101";
        mem[32] = "010100110";
        mem[33] = "111011011";
        mem[34] = "101101100";
        mem[35] = "011111010";
        mem[36] = "001011011";
        mem[37] = "100010001";
        mem[38] = "111110100";
        mem[39] = "101111111";
        mem[40] = "101001001";
        mem[41] = "110110111";
        mem[42] = "111011011";
        mem[43] = "011101010";
        mem[44] = "110110111";
        mem[45] = "111101011";
        mem[46] = "011101011";
        mem[47] = "011110000";
        mem[48] = "100110110";
        mem[49] = "101101010";
        mem[50] = "011001011";
        mem[51] = "000110101";
        mem[52] = "001001110";
        mem[53] = "110011111";
        mem[54] = "101001111";
        mem[55] = "011010110";
        mem[56] = "001100100";
        mem[57] = "110110011";
        mem[58] = "100101000";
        mem[59] = "001000101";
        mem[60] = "110111111";
        mem[61] = "001111101";
        mem[62] = "001111100";
        mem[63] = "101110110";
        mem[64] = "001000001";
        mem[65] = "011010101";
        mem[66] = "100101000";
        mem[67] = "101010011";
        mem[68] = "011010011";
        mem[69] = "101110110";
        mem[70] = "111011110";
        mem[71] = "110010010";
        mem[72] = "001010101";
        mem[73] = "101100001";
        mem[74] = "001000010";
        mem[75] = "011001000";
        mem[76] = "111001111";
        mem[77] = "010110101";
        mem[78] = "100001101";
        mem[79] = "100001111";
        mem[80] = "110011100";
        mem[81] = "000111010";
        mem[82] = "101011000";
        mem[83] = "111011010";
        mem[84] = "001011010";
        mem[85] = "001101001";
        mem[86] = "000010100";
        mem[87] = "010011100";
        mem[88] = "110010110";
        mem[89] = "100110101";
        mem[90] = "111101011";
        mem[91] = "110011111";
        mem[92] = "100001110";
        mem[93] = "001011100";
        mem[94] = "110101100";
        mem[95] = "000010000";
        mem[96] = "011100011";
        mem[97] = "110111001";
        mem[98] = "000110001";
        mem[99] = "101111001";
        mem[100] = "110100010";
        mem[101] = "110101000";
        mem[102] = "110100001";
        mem[103] = "001000010";
        mem[104] = "011110001";
        mem[105] = "101001001";
        mem[106] = "010011101";
        mem[107] = "010011010";
        mem[108] = "011100010";
        mem[109] = "110110111";
        mem[110] = "011110110";
        mem[111] = "000011100";
        mem[112] = "000100100";
        mem[113] = "110100111";
        mem[114] = "110011011";
        mem[115] = "000001100";
        mem[116] = "010101101";
        mem[117] = "011100010";
        mem[118] = "010101100";
        mem[119] = "010010110";
        mem[120] = "100101010";
        mem[121] = "110010110";
        mem[122] = "001010000";
        mem[123] = "101000101";
        mem[124] = "101100110";
        mem[125] = "110111110";
        mem[126] = "110000010";
        mem[127] = "001001011";
        mem[128] = "100011100";
        mem[129] = "110100001";
        mem[130] = "010001111";
        mem[131] = "000011000";
        mem[132] = "010101000";
        mem[133] = "100101001";
        mem[134] = "000000011";
        mem[135] = "001110100";
        mem[136] = "000100101";
        mem[137] = "010111010";
        mem[138] = "101100111";
        mem[139] = "011011110";
        mem[140] = "000101001";
        mem[141] = "001111000";
        mem[142] = "101110111";
        mem[143] = "100010111";
        mem[144] = "101101110";
        mem[145] = "101100010";
        mem[146] = "110010011";
        mem[147] = "000111110";
        mem[148] = "110101101";
        mem[149] = "110010101";
        mem[150] = "010000101";
        mem[151] = "100101111";
        mem[152] = "110000100";
        mem[153] = "011000001";
        mem[154] = "000010000";
        mem[155] = "100011011";
        mem[156] = "110101011";
        mem[157] = "011101001";
        mem[158] = "010101111";
        mem[159] = "111000111";
        mem[160] = "010000001";
        mem[161] = "010011110";
        mem[162] = "100110101";
        mem[163] = "000111011";
        mem[164] = "101101110";
        mem[165] = "001101100";
        mem[166] = "110010111";
        mem[167] = "110000011";
        mem[168] = "011011000";
        mem[169] = "101111101";
        mem[170] = "001110110";
        mem[171] = "101010110";
        mem[172] = "000001100";
        mem[173] = "000111101";
        mem[174] = "110011011";
        mem[175] = "001101110";
        mem[176] = "111001001";
        mem[177] = "001011000";
        mem[178] = "011000111";
        mem[179] = "110100011";
        mem[180] = "111011010";
        mem[181] = "001110100";
        mem[182] = "010010001";
        mem[183] = "000001000";
        mem[184] = "010010000";
        mem[185] = "000100000";
        mem[186] = "001101010";
        mem[187] = "111000011";
        mem[188] = "011111101";
        mem[189] = "001110011";
        mem[190] = "011001010";
        mem[191] = "111101110";
        mem[192] = "011101111";
        mem[193] = "010111100";
        mem[194] = "101011111";
        mem[195] = "010011011";
        mem[196] = "000011100";
        mem[197] = "011100011";
        mem[198] = "100001000";
        mem[199] = "010111000";
    }


    void proc_di()
    {
        sc_dt::sc_lv<DATA_WIDTH> dt;
        for (unsigned i = 0; i < WRITE_PORT_COUNT; i++) {
            for (unsigned j = 0; j < DATA_WIDTH; j++) {
                dt.set_bit(j, d.read()[i * DATA_WIDTH + j].value());
            }
            di[i].write(dt);
        }
    }

    void proc_wai()
    {
        sc_dt::sc_lv<ADDRESS_WIDTH> wat;
        for (unsigned i = 0; i < WRITE_PORT_COUNT; i++) {
            for (unsigned j = 0; j < ADDRESS_WIDTH; j++) {
                wat.set_bit(j, wa.read()[i * ADDRESS_WIDTH + j].value());
            }
            wai[i].write(wat);
        }
    }


    void proc_mem()
    {
        for (unsigned j = 0; j < WRITE_PORT_COUNT; j++) {
          if (we.read().get_bit(j) == 1) {
            unsigned i = wai[j].read().to_uint();
            if (!wai[j].read().is_01() || i >= WORD_COUNT) {
               cerr << "In memory model " << name() << ", during a write cycle\n";
               if (!wai[j].read().is_01()) 
                 cerr << "ERROR: address is not stable =" << wai[j].read() << endl;
               else
                 cerr << "ERROR: Address " << i << " for port '" << j << "' is outside the legal range [0.."
                      << (WORD_COUNT - 1) << "]." << endl;
               SC_REPORT_FATAL(1000, 0);
            }
            assert(wai[j].read().is_01());
            assert(i < WORD_COUNT);
            mem[i] = di[j];
          }
        }
    }


    void proc_rai()
    {
        sc_dt::sc_lv<ADDRESS_WIDTH> rat;
        for (unsigned i = 0; i < READ_PORT_COUNT; i++) {
            for (unsigned j = 0; j < ADDRESS_WIDTH; j++) {
                rat.set_bit(j, ra.read()[i * ADDRESS_WIDTH + j].value());
            }
            rai[i].write(rat);
        }
    }

    void proc_rai_reg()
    {
        for (unsigned i = 0; i < READ_PORT_COUNT; i++) {
            if ( ce.read().get_bit(i) == 1) {
                rai_reg[i] = rai[i];
            }
        }
    }

    void proc_qi()
    {
        sc_dt::sc_lv<DATA_WIDTH> qt;
        sc_dt::sc_lv<READ_PORT_COUNT*DATA_WIDTH> qit;
        for (unsigned i = 0; i < READ_PORT_COUNT; i++) {
            if (!(rai_reg[i].read().is_01())) 
                qt = sc_dt::sc_lv<DATA_WIDTH>();
            else 
            {
                unsigned addr = rai_reg[i].read().to_uint();
                if (addr >= WORD_COUNT) {
                    qt = sc_dt::sc_lv<DATA_WIDTH>();
                }
                else {
                    qt = mem[addr];
                }
            }
            for (unsigned j = 0; j < DATA_WIDTH; j++) {
                qit.set_bit(i*DATA_WIDTH+j, qt[j].value());
            }
        }
        qi.write(qit);
    }


    void proc_q()
    {
        q.write(qi.read());
    }

    ~runQueue_random_priorities_core() {
        delete [] mem;
    }

public:
    sc_dt::sc_lv< DATA_WIDTH>*  mem;
    sc_core::sc_signal<sc_dt::sc_lv<ADDRESS_WIDTH> > wai[ WRITE_PORT_COUNT ];
    sc_core::sc_signal<sc_dt::sc_lv<ADDRESS_WIDTH> > rai[READ_PORT_COUNT];
    sc_core::sc_signal<sc_dt::sc_lv<ADDRESS_WIDTH> > rai_reg[READ_PORT_COUNT];
    sc_core::sc_signal<sc_dt::sc_lv<DATA_WIDTH> > di[WRITE_PORT_COUNT];
    sc_core::sc_signal<sc_dt::sc_lv<READ_PORT_COUNT*DATA_WIDTH> > qi;
};

  


SC_MODULE( runQueue_random_priorities )
{
    static const unsigned int DataWidth = 9;
    static const unsigned int AddressRange = 200;
    static const unsigned int AddressWidth = 8;


    sc_core::sc_in<sc_dt::sc_lv<AddressWidth> > address0;
    sc_core::sc_in<sc_dt::sc_logic> ce0;
    sc_core::sc_out<sc_dt::sc_lv<DataWidth> > q0;

    sc_core::sc_in<sc_dt::sc_logic> reset;
    sc_core::sc_in_clk clk;


    SC_CTOR( runQueue_random_priorities ) {
        meminst = new runQueue_random_priorities_core <1, 1, DataWidth, AddressWidth, AddressRange>("core_inst");

        meminst->d(mem_d);
        meminst->q(mem_q);
        meminst->ra(mem_ra);
        meminst->ce(mem_ce);
        meminst->wa(mem_wa);
        meminst->we(mem_we);
        meminst->reset(reset);
        meminst->clk(clk);

        SC_METHOD(proc_mem_q);
        sensitive << mem_q;

        SC_METHOD(proc_mem_ra);
        sensitive << address0;

        SC_METHOD(proc_mem_ce);
        sensitive << ce0;

        mem_wa.write(0);
        mem_we.write(0);
        mem_d.write(0);
    }

    ~runQueue_random_priorities() {
        delete meminst;
    }

    void proc_mem_q();
    void proc_mem_ra();
    void proc_mem_ce();

public:
    sc_core::sc_signal<sc_dt::sc_lv<1 * DataWidth> > mem_q;
    sc_core::sc_signal<sc_dt::sc_lv<1> > mem_we;
    sc_core::sc_signal<sc_dt::sc_lv<1 * DataWidth> > mem_d;
    sc_core::sc_signal<sc_dt::sc_lv<1 * AddressWidth> > mem_wa;
    sc_core::sc_signal<sc_dt::sc_lv<1 * AddressWidth> > mem_ra;
    sc_core::sc_signal<sc_dt::sc_lv<1> > mem_ce;

    runQueue_random_priorities_core <1, 1, DataWidth, AddressWidth, AddressRange>* meminst;
};

#endif //_runQueue_random_priorities_H_
